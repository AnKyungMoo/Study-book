기본 RxJava의 이해
==================

옵저버블
--------

### 옵저버블이란

> 옵저버블은 전송된 데이터에 관해서 관찰(observe)할 수 있는 데이터의 출처다. 서로 다른 옵저버블을 하나의 옵저버블로 결합하는 것이 가능하고 기본적으로 리액티브 방식으로 데이터 스트림을 활용하는 범용 인터페이스다.

.just() 메소드를 이용하는 방법

```java
Observable.just("First item", "Second item");
```

위와같이 옵저버블을 생성하면 언제 데이터를 전송할지 설정하지 않은 것이다.</br> .just()와 같이 간단한 도구로 생성했다면 옵저버블은 구독한다고 하기 전까지는 데이터를 전송하지 않는다.

따라서 아래의 코드처럼 변경해주어야한다.

```java
Observable.just("First item", "Second item").subscribe();
```

이렇게 옵저버블은 누군가 구독해야 활성화된다.

### 핫 그리고 콜드 옵저버블

> 콜드 옵저버블은 일반적인 옵저버블 타입이다. 콜드 옵저버블은 구독자가 있기 전까지는 옵저버블로 아이템을 전송하지 않겠다는 의미다. 즉, 어떤 이벤트가 진행중이어도 .subscribe()가 호출되기 전에는 아이템은 생성되지 않고 전송되지 않는다는 뜻이다.
>
> 핫 옵저버블은 옵저버블이 만들어지면서 내부적으로 아이템을 생성(전송)한다. 생성된 상태나 정보들이 계속해서 업데이트되고 이 자료를 받을 준비가 됐는지 아닌지 전혀 신경 쓰지 않는다. 때문에 옵저버블에 대한 구독자가 아무도 없다면 업데이트된 데이터들은 잃어버리게 될 것이다.

디스포저블
----------

> 디스포저블은 옵저버블의 생애 주기를 제어하기 위해 사용하는 도구다. 만약 옵저버블이 생성하는 데이터의 스트림이 끝이 없다면 영원히 활성화 상태로 남아 있어야 한다는 의미가 된다. 이것은 메모리 누수의 원인이 될 수 있고 안드로이드에서 심각한 문제를 초래할 수 있다.

### dispose()

지금 존재하는 디스포저블(구독)을 취소할 때 사용한다. 즉 옵저버블로부터 더이상 아이템을 전송받지 않도록 .subscribe() 호출을 중지시킨다. 그리고 옵저버블은 스스로 정리된다.

### isDisposed()

구독이 활성화 상태인지 점검할 수 있다. 하지만 일반적인 코드에서는 잘 사용하지 않는데, 구독은 일반적으로 구독돼 있지 않거나 생각할 필요가 없기 때문이다.

취소된 디스포저블은 다시 사용할 수 없다. 사용하기 위해서는 다시 만들어야 한다.

디스포저블은 CompositeDisposable을 이용해 그룹화할 수 있다. 액티비티를 제거할 때 처럼 많은 옵저버블을 한 번에 취소해야 하는 경우 유용하게 사용할 수 있다.

```java
Disposable disposable = new CompositeDisposable(
  Observable.just("First item", "Second item").subscribe(),
  Observable.just("1", "2").subscribe(),
  Observable.just("One", "Two").subscribe()
);
```

스케줄러
--------

> 현재 또는 나중에 동작해야 할 단위의 일정을 만드는 것 실제로는 스케줄러를 이용해 코드가 어디서 실행돼야 하는지 제어할 수 있다는 의미이자 이것은 특정한 스레드를 선택할 수 있다는 뜻이다.</br> 대부분 구독자는 백그라운드 스레드에서 긴 시간 동안 실행되는 작업을 하므로 주요 계산 처리나 UI 스레드를 방해하지 않을 것이다. 특히 오랫동안 동작하면서 메인 스레드에서 실행하면 안되는 모든 안드로이드 코드와 관계가 있다.

플로어블
--------

> 대부분은 옵저버블과 비슷한 메소드의 특징을 갖고 있다. 하지만 플로어블을 이용하면 출처로부터 다음 단계 중 일부가 처리하는 것보다 더 빨리 방출된 아이템들을 처리할 수 있다.

### 아이템 버리기

아이템 버리기는 스트리밍을 받아 처리하는 단계에서 원천 옵저버블의 속도를 따라잡지 못할 때, 처리하지 못하는 아이템을 그냥 버리는 것이다. 데이터를 버려도 문제 없을 때만 사용할 수 있으며 방출되는 데이터의 가치를 처음부터 신경써야 한다.

아이템 버리기는 여러 가지 방법으로 사용할 수 있다.

```java
Observable.toFlowable(BackpressureStrategy.DROP);
```

```java
Observable.toFlowable(BackpressureStrategy.MISSING)
          .onBackpressureDrop()
```

### 마지막 아이템 유지하기

다운스트림으로 전송되는 아이템을 처리할 수 없을 때, 앱은 처리 가능할 때까지 값을 방출하는 것을 멈춘다. 멈춰 있는 동안 넘어오는 모든 값을 버리면서 나머지 값만 남겨둔다. 그리고 처리할 수 있는 상황이 되면 마지막으로 저장된 메시지를 전송한다.

마지막 아이템 유지하기는 여러 가지 방법으로 사용할 수 있다.

```java
Observable.toFlowable(BackpressureStrategy.LATEST);
```

```java
Observable.toFlowable(BackpressureStrategy.MISSING)
          .onBackpressureLatest()
```

### 버퍼링

방출되고 소비되는 아이템의 속도가 다른 것을 다룰 때 좋지 않은 방법이다. 앞으로 생길 문제를 미루는 격. 하지만 consumer중 하나에서 일시적인 속도 둔화라면 문제없이 동작할 것이다. 만약 consumer가 따라잡지 못하면 일정 시점에서 버퍼는 고갈되고 원래의 옵저버블에서 메모리 고갈과 매우 비슷한 증상을 보게 될 수 있다.

버퍼링은 여러 가지 방법으로 사용할 수 있다.

```java
Observable.toFlowable(BackpressureStrategy.BUFFER);
```

```java
Observable.toFlowable(BackpressureStrategy.MISSING)
          .onBackpressureBuffer()
```

버퍼에 특정 수치를 지정하고 싶으면 .buffer()를 사용할 수 있다.

```java
Observable.toFlowable(BackpressureStrategy.MISSING)
          .buffer(10)
```

컴플리터블, 싱글, 메이비 타입
-----------------------------

1.	Completable: 미래에 완료될 결과가 없는 행위를 나타낸다.
2.	Single: 옵저버블(또는 플로어블)과 비슷하지만 스트림 대신에 하나의 아이템을 반환한다.
3.	Maybe: 어떠한 값의 반환 없이 완료 또는 실패할 수 있는 행위를 의미한다. 하지만 싱글과 같이 아이템을 반환할 수 있다.(반환되지 않을 수도 있다.)

이 3가지는 많이 사용하진 않는다.
